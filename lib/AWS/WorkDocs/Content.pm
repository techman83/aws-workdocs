package AWS::WorkDocs::Content;

use v5.010;
use strict;
use warnings;
use Moo;
use Method::Signatures;
use Scalar::Util::Reftype;
use experimental 'switch';
use Data::Dumper;
use Carp qw(croak);
use AWS::WorkDocs::User;

# ABSTRACT: A WorkDocs Content Object 

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

  extends 'AWS::WorkDocs::Content';
    
  Parent class for Documents/Folders (Which share methods);
   
=head1 DESCRIPTION

All WorkDocs documents/folders have unique Ids and can be 
shared/unshared through similar API methods. API wise Folders 
+ Documents differ slightly, but we treat them the same.

=cut

my $Ref = sub {
  croak "auth isn't a 'AWS::WorkDocs::Auth' object!" unless reftype( $_[0] )->class eq "AWS::WorkDocs::Auth";
};

# Authentication Object
has 'auth'        => ( is => 'ro', required => 1, isa => $Ref );

# Attributes
has 'Id'          => ( is => 'ro', required => 1 );
has '_type'       => ( is => 'ro', default => sub { return lc(&_build_Type)} );
has '_Type'       => ( is => 'ro', builder => "_build_Type" );

method _build_content() {
  my $content;
  $content = $self->auth->api_get("/$self->{_type}/$self->{Id}");
  $self->_map_keys($content);  
}

method _map_keys($data) {
  foreach my $key (keys %{ $data->{$self->{_Type}} }) {
    $self->{$key} = $data->{$self->{_Type}}{$key}; 
  }
}

method _build_Type() {
  given ( reftype( $self )->class) {
    when    ("AWS::WorkDocs::Content::Folder")    { return "Folder"; }
    when    ("AWS::WorkDocs::Content::Document")  { return "Document"; }
    default {croak "Extending class neither document or folder";}
  }
}

=method retrieve

  $content->retrieve();

This will attempt to retrieve the Content object with the associated 
'Id'

=cut

method retrieve() {
  $self->_build_content();
  return;
}

=method org_share

  $content->org_share();

This will share the content with the entire organisation.

=cut

method org_share() {
  $self->_org_share(1);
}

=method org_unshare

  $content->org_unshare();

This will deactivate an org wide share.

=cut

method org_unshare() {
  $self->_org_share(0);
}

method _org_share($state = 0) {
  my $result;
  my $body;
  if ($state) {
    $body->{ShareWithOrganization} = "true";
    $result = $self->auth->api_post("/$self->{_type}/$self->{Id}/share", $body);
  } else {
    $body->{ShareWithOrganization} = "false";
    $result = $self->auth->api_post("/$self->{_type}/$self->{Id}/share", $body);
  }
}

# The following method differs code wise, but the exposed method is 
# the same between both Document/Folder. See the relevant packages
# for the code.

=method user_share

  $content->user_share(%parms)

Takes named parameters of 'users' and 'access'

=over

=item users

'users' will take a single username (WorkDocs usernames are email 
addresses) or an array of usernames.

=item access

'access' will default to 'VIEWER' unless otherwise specified. The
other acceptable values are 'CONTRIBUTOR', 'COOWNER' or 'OWNER'.

=back

=cut

method user_share(:$users,:$access = "VIEWER", :$message = "") {
  $access = uc($access);
  if ($access !~ /COOWNER|VIEWER|OWNER|CONTRIBUTOR/) {
    croak("$access not valid, only [COOWNER, VIEWER, OWNER, CONTRIBUTOR] are valid types");
  }

  my $body;
  if ( reftype( $users )->array ) {
    foreach my $user ( @{$users} ) {
      $user = AWS::WorkDocs::User->new( EmailAddress => $user, auth => $self->auth);
      $user->retrieve();
      my $permission = {
        Id => $user->Id,
        Type => "USER",
        Role => $access,
      };
      push(@{$body->{Principals}}, $permission);
    }
  } else {
    $users = AWS::WorkDocs::User->new( EmailAddress => $users, auth => $self->auth);
    $users->retrieve();
    my $permission = {
      Id => $users->Id,
      Type => "USER",
      Role => $access,
    };
    push(@{$body->{Principals}}, $permission);
  }
  
  $body->{Options}{Email}{Message} = $message;
  $self->auth->api_put("/resource/".$self->Id."/permissions", $body);
  $self->retrieve;
}

=method user_unshare

  $content->user_unshare( users => \@users );

'users' will also accept a single username along with an array of
usernames.

=cut

method user_unshare(:$users) {
  my $result;
  if ( reftype( $users )->array ) {
    foreach my $user ( @{$users} ) {
      $user = AWS::WorkDocs::User->new( EmailAddress => $user, auth => $self->auth);
      $user->retrieve();
      $self->auth->api_delete("/resource/".$self->Id."/permissions/".$user->Id);
    }
  } else {
    $users = AWS::WorkDocs::User->new( EmailAddress => $users, auth => $self->auth);
    $users->retrieve();
    $self->auth->api_delete("/resource/".$self->Id."/permissions/".$users->Id);
  }
  $self->retrieve;
}

=method shared_users

  $content->shared_users();

Will return an array of L<AWS::WorkDocs::User> objects.

=cut

method shared_users() {
  $self->retrieve;
  
  my @users;
  foreach my $permission ( @{$self->{Metadata}{PermissionsGranted}} ) {
    $permission->{User} = AWS::WorkDocs::User->new(%{$permission->{User}}, auth => $self->auth);
    push(@users, $permission);
  }

  return @users;
}

=method shared_usernames

  $content->shared_usernames();

Returns an array of usernames shared with the content.

=cut

method shared_usernames() {
  $self->retrieve;
  
  my @users;
  foreach my $permission ( @{$self->{Metadata}{PermissionsGranted}} ) {
    push(@users, $permission->{User}{Username});
  }
  
  return @users;
}

1;
