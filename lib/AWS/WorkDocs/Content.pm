package AWS::WorkDocs::Content;

use v5.010;
use strict;
use warnings;
use Scalar::Util::Reftype;
use Data::Dumper;
use Carp qw(croak);
use Method::Signatures;
use Moo;
use experimental 'switch';
use namespace::clean;

# ABSTRACT: A WorkDocs Content Object 

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

  extends 'AWS::WorkDocs::Content';
    
  Parent class for Documents/Folders (Which share methods);
   
=head1 DESCRIPTION

All WorkDocs documents/folders have unique Ids and can be 
shared/unshared through similar API methods. API wise Folders 
+ Documents differ slightly, but we treat them the same.

=cut

my $Ref = sub {
  croak "auth isn't a 'AWS::WorkDocs::Auth' object!" unless $_[0]->DOES("AWS::WorkDocs::Auth");
};

# Authentication Object
has 'auth'        => ( is => 'ro', required => 1, isa => $Ref );

# Attributes
has 'Id'          => ( is => 'ro', required => 1 );
has '_type'       => ( is => 'ro', default => sub { return lc(&_build_Type)} );
has '_Type'       => ( is => 'ro', builder => "_build_Type" );

method _build_content() {
  my $content;
  $content = $self->auth->api_get("/".$self->_type."/".$self->Id);
  $self->_map_keys($content);  
}

method _map_keys($data) {
  foreach my $key (keys %{ $data->{$self->_Type} }) {
    if ( $key eq 'Folders' && @{$data->{$self->_Type}{$key}}[0]) {
      $self->_push_folders($data->{$self->_Type}{$key});
    } else {
      $self->{$key} = $data->{$self->_Type}{$key}; 
    }
  }
}

method _build_Type() {
  given ( reftype( $self )->class) {
    when    ("AWS::WorkDocs::Content::Folder")    { return "Folder"; }
    when    ("AWS::WorkDocs::Content::Document")  { return "Document"; }
    default {croak "Extending class neither document or folder";}
  }
}

=method retrieve

  $content->retrieve();

This will attempt to retrieve the Content object with the associated 
'Id'

=cut

method retrieve() {
  $self->_build_content();
  return;
}

# TODO: Find out new method for org wide sharing
#=method org_share
#
#  $content->org_share();
#
#This will share the content with the entire organisation.
#
#=cut
#
#method org_share() {
#  $self->_org_share(1);
#}
#
#=method org_unshare
#
#  $content->org_unshare();
#
#This will deactivate an org wide share.
#
#=cut
#
#method org_unshare() {
#  $self->_org_share(0);
#}
#
#method _org_share($state = 0) {
#  my $result;
#  my $body;
#  if ($state) {
#    $body->{ShareWithOrganization} = "true";
#    $result = $self->auth->api_post("/$self->{_type}/$self->{Id}/share", $body);
#  } else {
#    $body->{ShareWithOrganization} = "false";
#    $result = $self->auth->api_post("/$self->{_type}/$self->{Id}/share", $body);
#  }
#}

=method user_share

  $content->user_share(%parms)

Takes named parameters of 'users' and 'access'

=over

=item users

'users' will take a single username (WorkDocs usernames are email 
addresses) or an array of usernames.

=item access

'access' will default to 'VIEWER' unless otherwise specified. The
other acceptable values are 'CONTRIBUTOR', 'COOWNER' or 'OWNER'.

=back

=cut

method user_share(:$users,:$access = "VIEWER", :$message = "") {
  use AWS::WorkDocs::User;
  $access = uc($access);
  if ($access !~ /COOWNER|VIEWER|OWNER|CONTRIBUTOR/) {
    croak("$access not valid, only [COOWNER, VIEWER, OWNER, CONTRIBUTOR] are valid types");
  }

  my $body;
  if ( reftype( $users )->array ) {
    foreach my $user ( @{$users} ) {
      my $user_object = AWS::WorkDocs::User->new( EmailAddress => $user, auth => $self->auth);
      $user_object->retrieve();
      my $permission = {
        Id => $user_object->Id,
        Type => "USER",
        Role => $access,
      };
      push(@{$body->{Principals}}, $permission);
    }
  } else {
    my $user_object = AWS::WorkDocs::User->new( EmailAddress => $users, auth => $self->auth);
    $user_object->retrieve();
    my $permission = {
      Id => $user_object->Id,
      Type => "USER",
      Role => $access,
    };
    push(@{$body->{Principals}}, $permission);
  }
  
  $body->{Options}{Email}{Message} = $message;
  $self->auth->api_put("/resource/".$self->Id."/permissions", $body);
  $self->retrieve;
}

=method user_unshare

  $content->user_unshare( users => \@users );

'users' will also accept a single username along with an array of
usernames.

=cut

method user_unshare(:$users) {
  use AWS::WorkDocs::User;
  my $result;
  if ( reftype( $users )->array ) {
    foreach my $user ( @{$users} ) {
      my $user_object = AWS::WorkDocs::User->new( EmailAddress => $user, auth => $self->auth);
      $user_object->retrieve();
      $self->auth->api_delete("/resource/".$self->Id."/permissions/".$user_object->Id);
    }
  } else {
    my $user_object = AWS::WorkDocs::User->new( EmailAddress => $users, auth => $self->auth);
    $user_object->retrieve();
    $self->auth->api_delete("/resource/".$self->Id."/permissions/".$user_object->Id);
  }
  $self->retrieve;
}

=method shared_users

  $content->shared_users();

Will return an array of L<AWS::WorkDocs::User> objects.

=cut

method shared_users() {
  use AWS::WorkDocs::User;
  $self->retrieve;
  
  my @users;
  foreach my $permission ( @{$self->{Metadata}{PermissionsGranted}} ) {
    $permission->{User} = AWS::WorkDocs::User->new(%{$permission->{User}}, auth => $self->auth);
    push(@users, $permission);
  }

  return @users;
}

=method shared_usernames

  $content->shared_usernames();

Returns an array of usernames shared with the content.

=cut

method shared_usernames() {
  $self->retrieve;
  
  my @users;
  foreach my $permission ( @{$self->{Metadata}{PermissionsGranted}} ) {
    push(@users, $permission->{User}{Username});
  }
  
  return @users;
}

1;
